#ifndef STRING_CONVERT_H
#define STRING_CONVERT_H

#include <Arduino.h>

void convert_string_to_byte(String string, byte data[], char chars[], int & stringSize)
{
  // This lookup table is not my own; it was taken from:
  // https://www.devacron.com/scrolling-text-with-arduino-uno-and-max7219-led-matrix/
  
  const byte CH[665] = {
    3, 8, B00000000, B00000000, B00000000, B00000000, B00000000, // space
    1, 8, B01011111, B00000000, B00000000, B00000000, B00000000, // !
    3, 8, B00000011, B00000000, B00000011, B00000000, B00000000, // "
    5, 8, B00010100, B00111110, B00010100, B00111110, B00010100, // #
    4, 8, B00100100, B01101010, B00101011, B00010010, B00000000, // $
    5, 8, B01100011, B00010011, B00001000, B01100100, B01100011, // %
    5, 8, B00110110, B01001001, B01010110, B00100000, B01010000, // &
    1, 8, B00000011, B00000000, B00000000, B00000000, B00000000, // '
    3, 8, B00011100, B00100010, B01000001, B00000000, B00000000, // (
    3, 8, B01000001, B00100010, B00011100, B00000000, B00000000, // )
    5, 8, B00101000, B00011000, B00001110, B00011000, B00101000, // *
    5, 8, B00001000, B00001000, B00111110, B00001000, B00001000, // +
    2, 8, B10110000, B01110000, B00000000, B00000000, B00000000, // ,
    4, 8, B00001000, B00001000, B00001000, B00001000, B00000000, // -
    2, 8, B01100000, B01100000, B00000000, B00000000, B00000000, // .
    4, 8, B01100000, B00011000, B00000110, B00000001, B00000000, // /
    4, 8, B00111110, B01000001, B01000001, B00111110, B00000000, // 0
    3, 8, B01000010, B01111111, B01000000, B00000000, B00000000, // 1
    4, 8, B01100010, B01010001, B01001001, B01000110, B00000000, // 2
    4, 8, B00100010, B01000001, B01001001, B00110110, B00000000, // 3
    4, 8, B00011000, B00010100, B00010010, B01111111, B00000000, // 4
    4, 8, B00100111, B01000101, B01000101, B00111001, B00000000, // 5
    4, 8, B00111110, B01001001, B01001001, B00110000, B00000000, // 6
    4, 8, B01100001, B00010001, B00001001, B00000111, B00000000, // 7
    4, 8, B00110110, B01001001, B01001001, B00110110, B00000000, // 8
    4, 8, B00000110, B01001001, B01001001, B00111110, B00000000, // 9
    2, 8, B01010000, B00000000, B00000000, B00000000, B00000000, // :
    2, 8, B10000000, B01010000, B00000000, B00000000, B00000000, // ;
    3, 8, B00010000, B00101000, B01000100, B00000000, B00000000, // <
    3, 8, B00010100, B00010100, B00010100, B00000000, B00000000, // =
    3, 8, B01000100, B00101000, B00010000, B00000000, B00000000, // >
    4, 8, B00000010, B01011001, B00001001, B00000110, B00000000, // ?
    5, 8, B00111110, B01001001, B01010101, B01011101, B00001110, // @
    4, 8, B01111110, B00010001, B00010001, B01111110, B00000000, // A
    4, 8, B01111111, B01001001, B01001001, B00110110, B00000000, // B
    4, 8, B00111110, B01000001, B01000001, B00100010, B00000000, // C
    4, 8, B01111111, B01000001, B01000001, B00111110, B00000000, // D
    4, 8, B01111111, B01001001, B01001001, B01000001, B00000000, // E
    4, 8, B01111111, B00001001, B00001001, B00000001, B00000000, // F
    4, 8, B00111110, B01000001, B01001001, B01111010, B00000000, // G
    4, 8, B01111111, B00001000, B00001000, B01111111, B00000000, // H
    3, 8, B01000001, B01111111, B01000001, B00000000, B00000000, // I
    4, 8, B00110000, B01000000, B01000001, B00111111, B00000000, // J
    4, 8, B01111111, B00001000, B00010100, B01100011, B00000000, // K
    4, 8, B01111111, B01000000, B01000000, B01000000, B00000000, // L
    5, 8, B01111111, B00000010, B00001100, B00000010, B01111111, // M
    5, 8, B01111111, B00000100, B00001000, B00010000, B01111111, // N
    4, 8, B00111110, B01000001, B01000001, B00111110, B00000000, // O
    4, 8, B01111111, B00001001, B00001001, B00000110, B00000000, // P
    4, 8, B00111110, B01000001, B01000001, B10111110, B00000000, // Q
    4, 8, B01111111, B00001001, B00001001, B01110110, B00000000, // R
    4, 8, B01000110, B01001001, B01001001, B00110010, B00000000, // S
    5, 8, B00000001, B00000001, B01111111, B00000001, B00000001, // T
    4, 8, B00111111, B01000000, B01000000, B00111111, B00000000, // U
    5, 8, B00001111, B00110000, B01000000, B00110000, B00001111, // V
    5, 8, B00111111, B01000000, B00111000, B01000000, B00111111, // W
    5, 8, B01100011, B00010100, B00001000, B00010100, B01100011, // X
    5, 8, B00000111, B00001000, B01110000, B00001000, B00000111, // Y
    4, 8, B01100001, B01010001, B01001001, B01000111, B00000000, // Z
    2, 8, B01111111, B01000001, B00000000, B00000000, B00000000, // [
    4, 8, B00000001, B00000110, B00011000, B01100000, B00000000, // \ backslash
    2, 8, B01000001, B01111111, B00000000, B00000000, B00000000, // ]
    3, 8, B00000010, B00000001, B00000010, B00000000, B00000000, // hat
    4, 8, B01000000, B01000000, B01000000, B01000000, B00000000, // _
    2, 8, B00000001, B00000010, B00000000, B00000000, B00000000, // `
    4, 8, B00100000, B01010100, B01010100, B01111000, B00000000, // a
    4, 8, B01111111, B01000100, B01000100, B00111000, B00000000, // b
    4, 8, B00111000, B01000100, B01000100, B00101000, B00000000, // c
    4, 8, B00111000, B01000100, B01000100, B01111111, B00000000, // d
    4, 8, B00111000, B01010100, B01010100, B00011000, B00000000, // e
    3, 8, B00000100, B01111110, B00000101, B00000000, B00000000, // f
    4, 8, B10011000, B10100100, B10100100, B01111000, B00000000, // g
    4, 8, B01111111, B00000100, B00000100, B01111000, B00000000, // h
    3, 8, B01000100, B01111101, B01000000, B00000000, B00000000, // i
    4, 8, B01000000, B10000000, B10000100, B01111101, B00000000, // j
    4, 8, B01111111, B00010000, B00101000, B01000100, B00000000, // k
    3, 8, B01000001, B01111111, B01000000, B00000000, B00000000, // l
    5, 8, B01111100, B00000100, B01111100, B00000100, B01111000, // m
    4, 8, B01111100, B00000100, B00000100, B01111000, B00000000, // n
    4, 8, B00111000, B01000100, B01000100, B00111000, B00000000, // o
    4, 8, B11111100, B00100100, B00100100, B00011000, B00000000, // p
    4, 8, B00011000, B00100100, B00100100, B11111100, B00000000, // q
    4, 8, B01111100, B00001000, B00000100, B00000100, B00000000, // r
    4, 8, B01001000, B01010100, B01010100, B00100100, B00000000, // s
    3, 8, B00000100, B00111111, B01000100, B00000000, B00000000, // t
    4, 8, B00111100, B01000000, B01000000, B01111100, B00000000, // u
    5, 8, B00011100, B00100000, B01000000, B00100000, B00011100, // v
    5, 8, B00111100, B01000000, B00111100, B01000000, B00111100, // w
    5, 8, B01000100, B00101000, B00010000, B00101000, B01000100, // x
    4, 8, B10011100, B10100000, B10100000, B01111100, B00000000, // y
    3, 8, B01100100, B01010100, B01001100, B00000000, B00000000, // z
    3, 8, B00001000, B00110110, B01000001, B00000000, B00000000, // {
    1, 8, B01111111, B00000000, B00000000, B00000000, B00000000, // |
    3, 8, B01000001, B00110110, B00001000, B00000000, B00000000, // }
    4, 8, B00001000, B00000100, B00001000, B00000100, B00000000, // ~
  };

  const int ROW_LENGTH = 7;
  const int ASCII_OFFSET = 32; // each "row" of the lookup table corresponds to an ASCII code with an offset of 32
  const int SPACING = 1; // custom spacing; can be changed by the user 
  const int DATA_OFFSET = 2; // the graphical data in each "row" of the lookup table is on the second index

  int stringLength = string.length()+1; // "+1" is for the null terminator
  char tempChars[stringLength];
  string.toCharArray(tempChars, stringLength);

  // copying the characters in array "tempChars" to array "chars"
  for (int c = 0; c < stringLength; c++)
  {
    chars[c] = B00000000; // element is reset to empty byte in case it was modified before function call
    chars[c] = tempChars[c];
  }

  // resetting the pass by reference value in case it was modified before function call
  stringSize = 0;

  // iterating over each character in the string
  for (int charPos = 0; charPos < stringLength; charPos++)
  {
    int characterPos = (chars[charPos]-ASCII_OFFSET)*ROW_LENGTH; // index of each "row" in the lookup table

    // last value is always the null terminator, so characterPos is negative. Here it is replaced to be a space
    if (charPos == stringLength-1)
    {
      characterPos = 0;
    }

    // the first elements of each row in the lookup table
    int charLength = CH[characterPos];

    // populating the "data" array with the display data from the lookup table
    for (int pos = 0; pos < charLength; pos++)
    {
      data[stringSize] = CH[characterPos + pos + DATA_OFFSET];
      stringSize++;
    }

    // adding spacing between characters
    for (int space = 0; space < SPACING; space++)
    {
      data[stringSize] = CH[DATA_OFFSET]; // CH[DATA_OFFSET] is an empty column
      stringSize++;
    }
  }
}

#endif
